# 7章: コードレビュー活用法

⏱️ **所要時間**: 座学15分

## 📋 この章の目標

- [ ] AIコードレビューの強みを理解する
- [ ] レビュー依頼の効果的な方法を学ぶ
- [ ] 実務での活用パターンを知る

---

## 🎯 コードレビューとは

**コードレビュー** = 書いたコードを第三者がチェックして改善提案をすること

### 従来のコードレビュー

```
自分が書く → 先輩エンジニアにレビュー依頼 → フィードバック → 修正
```

**問題点**:
- ⏰ レビュー待ち時間が発生
- 😰 指摘されると精神的にキツい
- 💸 先輩の時間を使う（コスト高）

### AIコードレビュー

```
自分が書く → Claude Codeにレビュー依頼 → 即座にフィードバック → 修正
```

**メリット**:
- ⚡ 即座にフィードバック
- 😊 心理的ハードルが低い
- 💰 何度でも無料
- 🌙 24時間いつでも可能

---

## 🤖 AIコードレビューの強み

### 強み1: 網羅的なチェック

人間のレビュー:
- 見落としがある
- 疲労で精度が落ちる
- 得意分野に偏る

AIレビュー:
- ✅ すべてのコードを平等にチェック
- ✅ 疲れない
- ✅ 多角的な視点

### 強み2: 教育的なフィードバック

```
人間のレビュー:
「ここダメ」

AIレビュー:
「ここを改善できます。なぜなら...
こうすることで、パフォーマンスが向上します。
参考: [関連ドキュメント]」
```

### 強み3: 即座の対話

```
レビュー → 質問 → 回答 → 再修正 → 再レビュー

すべてが数分で完結
```

---

## 📝 効果的なレビュー依頼の仕方

### パターン1: 全体レビュー

```
💬 「このコードをレビューしてください。

レビュー観点:
- セキュリティ
- パフォーマンス
- 可読性
- ベストプラクティス準拠」
```

### パターン2: 特定観点レビュー

```
💬 「このコードのセキュリティ面をレビューしてください。
特にXSS脆弱性とSQLインジェクション対策を重点的にチェックしてください」
```

### パターン3: 改善提案

```
💬 「このコードをより読みやすく改善してください。
変数名、関数名、コメントの改善提案をお願いします」
```

### パターン4: パフォーマンス最適化

```
💬 「このコードのパフォーマンスを改善してください。
現在、1000件のデータ処理に5秒かかっています。
もっと高速化できますか？」
```

---

## 🎨 レビューで見るべきポイント

### 1. セキュリティ

```javascript
// ❌ 危険なコード
element.innerHTML = userInput;  // XSS脆弱性

// ✅ 安全なコード
element.textContent = userInput;  // エスケープされる
```

**レビュー依頼**:
```
💬 「このコードにXSS脆弱性はありませんか？」
```

### 2. パフォーマンス

```javascript
// ❌ 非効率
for (let i = 0; i < array.length; i++) {
  // array.lengthが毎回計算される
}

// ✅ 効率的
const len = array.length;
for (let i = 0; i < len; i++) {
  // 1回だけ計算
}
```

**レビュー依頼**:
```
💬 「このループ処理を最適化できますか？」
```

### 3. 可読性

```javascript
// ❌ 読みにくい
function f(a,b){return a>b?a:b}

// ✅ 読みやすい
function getMaxValue(valueA, valueB) {
  return valueA > valueB ? valueA : valueB;
}
```

**レビュー依頼**:
```
💬 「このコードをもっと読みやすくしてください」
```

### 4. エラーハンドリング

```javascript
// ❌ エラー処理なし
const data = JSON.parse(userInput);

// ✅ エラー処理あり
try {
  const data = JSON.parse(userInput);
} catch (error) {
  console.error('JSONパースエラー:', error);
  // エラー時の処理
}
```

**レビュー依頼**:
```
💬 「このコードにエラーハンドリングを追加してください」
```

---

## 💼 実務での活用パターン

### ケース1: 副業案件の品質チェック

```
状況: クライアントに納品する前

手順:
1. 自分でコードを書く
2. Claude Codeに全体レビュー依頼
3. 指摘された箇所を修正
4. 再レビュー → OKなら納品

効果:
- バグが減る
- クライアント満足度向上
- リピート案件につながる
```

### ケース2: 技術面接の準備

```
状況: ポートフォリオを面接官に見せる

手順:
1. 自分の作品をClaude Codeでレビュー
2. 指摘された部分を改善
3. 「なぜこう書いたか」説明を準備

効果:
- 面接で自信を持って説明できる
- 技術的な質問に的確に答えられる
- 採用率アップ
```

### ケース3: チーム開発での事前チェック

```
状況: Pull Requestを出す前

手順:
1. 自分のコードをAIレビュー
2. 明らかな問題を事前に修正
3. 人間のレビュアーへ提出

効果:
- レビュー指摘が減る
- レビュー時間短縮
- チーム全体の生産性向上
```

---

## 🚫 AIレビューの限界

### できること
- ✅ コードの構造分析
- ✅ ベストプラクティスとの比較
- ✅ 一般的な脆弱性の検出
- ✅ 可読性の改善提案

### できないこと
- ❌ ビジネスロジックの正しさ判定
- ❌ プロジェクト固有のルール判定
- ❌ 実際の動作確認
- ❌ チーム方針との整合性確認

### 併用のススメ

```
AIレビュー（即座に）
    ↓
自分で修正
    ↓
人間レビュー（最終確認）
```

**効果**:
- AIで基本的な問題を潰す
- 人間は高度な判断に集中
- レビュー時間が大幅短縮

---

## 📈 レビューで成長する

### レビュー結果を記録

```markdown
# レビュー学習ノート

## 2025/01/15
指摘: innerHTML使用でXSS脆弱性
学び: textContentを使うべき
今後: ユーザー入力は必ずエスケープ

## 2025/01/16
指摘: ループ内でDOM操作が遅い
学び: DocumentFragmentを使う
今後: DOM操作は最小限にまとめる
```

### パターンを蓄積

よくある指摘をテンプレート化:
```
私の弱点チェックリスト:
□ XSS対策はOK？
□ エラーハンドリングは十分？
□ 変数名は明確？
□ コメントは適切？
```

---

## ✅ この章のまとめ

- **AIレビューの強み**: 即座、網羅的、教育的
- **効果的な依頼**: 観点を明確に、段階的に
- **実務活用**: 納品前、面接準備、チーム開発
- **限界を理解**: 最終的には人間の判断が必要

---

## 🔗 次のステップ

次は **8章: コードを改善する** で、実際にレビューを受けて改善する実践をします！
# 8章: コードを改善する

⏱️ **所要時間**: 実践45分

## 📋 この章の目標

- [ ] 実際にコードレビューを依頼できる
- [ ] レビュー結果を理解して改善できる
- [ ] Before/Afterで品質向上を体感する

---

## 🎯 今回やること

6章で作った **経費精算アプリ** をClaude Codeにレビューしてもらい、改善します。

### 改善する観点
1. セキュリティ
2. パフォーマンス
3. 可読性
4. エラーハンドリング

---

## 🚀 ハンズオン（45分）

### ステップ1: プロジェクトを開く（2分）

```bash
cd expense-tracker
claude
```

6章で作った `index.html` を開きます。

### ステップ2: 全体レビューを依頼（10分）

Claude Codeに以下のように依頼：

```
💬 「index.htmlのコードをレビューしてください。

以下の観点でチェックしてください:
1. セキュリティ（XSS、入力バリデーション）
2. パフォーマンス（DOM操作の最適化）
3. 可読性（変数名、関数名、コメント）
4. エラーハンドリング（try-catch、ユーザーへのフィードバック）
5. ベストプラクティス（モダンなJavaScript記法）

各項目について、具体的な改善提案をお願いします。」
```

**Claude Codeの応答例**:
```
レビュー結果:

【セキュリティ】
⚠️ 問題: innerHTML使用でXSS脆弱性の可能性
場所: 行123
提案: textContentまたはcreateElementを使用

【パフォーマンス】
⚠️ 問題: ループ内でDOM操作が頻繁
場所: 行156-170
提案: DocumentFragmentを使用してまとめて追加

【可読性】
⚠️ 問題: 関数名が不明確
場所: renderList()
提案: renderExpenseList()に変更

...
```

**やること**:
- レビュー結果を読む
- 各指摘の理由を理解する
- 優先順位をつける（セキュリティ > パフォーマンス > 可読性）

### ステップ3: セキュリティ改善（10分）

**指摘1: innerHTML使用**

```
💬 「XSS脆弱性の指摘について、具体的にどう修正すればいいですか？
現在のコードと修正後のコードを見せてください」
```

**修正前**:
```javascript
element.innerHTML = `<div>${userInput}</div>`;
```

**修正後**:
```javascript
const div = document.createElement('div');
div.textContent = userInput;  // 自動エスケープ
element.appendChild(div);
```

**修正を依頼**:
```
💬 「index.htmlのすべてのinnerHTML使用箇所を、
XSS対策済みのコードに修正してください」
```

**指摘2: 入力バリデーション不足**

```
💬 「金額入力のバリデーションを強化してください。
- 負の数を入力できないようにする
- 100万円を超える金額は警告を出す
- 小数点以下は四捨五入する」
```

### ステップ4: パフォーマンス改善（10分）

**指摘: DOM操作の最適化**

```
💬 「経費一覧の描画を最適化してください。
現在、1件ずつDOM追加していますが、
DocumentFragmentを使ってまとめて追加する方式に変更してください」
```

**修正前**:
```javascript
expenses.forEach(expense => {
  const item = createExpenseItem(expense);
  list.appendChild(item);  // 毎回DOM更新
});
```

**修正後**:
```javascript
const fragment = document.createDocumentFragment();
expenses.forEach(expense => {
  const item = createExpenseItem(expense);
  fragment.appendChild(item);  // メモリ上で構築
});
list.appendChild(fragment);  // 1回だけDOM更新
```

**効果測定**:
```
💬 「修正前後でパフォーマンスはどれくらい改善しましたか？」
```

### ステップ5: 可読性改善（8分）

**指摘: 変数名・関数名**

```
💬 「以下の関数名をより明確にしてください:
- calc() → calculateMonthlyTotal()
- update() → updateExpenseList()
- render() → renderExpenseSummary()

また、マジックナンバー（1000, 500など）を
定数として定義してください」
```

**修正例**:
```javascript
// 修正前
if (amount > 1000000) {
  alert('高額です');
}

// 修正後
const MAX_EXPENSE_AMOUNT = 1000000;
const HIGH_AMOUNT_WARNING = '金額が高額です。確認してください。';

if (amount > MAX_EXPENSE_AMOUNT) {
  alert(HIGH_AMOUNT_WARNING);
}
```

**コメント追加**:
```
💬 「主要な関数にJSDocコメントを追加してください。
各関数の目的、引数、戻り値を明記してください」
```

### ステップ6: エラーハンドリング追加（5分）

```
💬 「以下のエラーハンドリングを追加してください:

1. localStorageアクセス失敗時の処理
   - プライベートモードで動作しない場合がある
   - エラー時はメモリ上でのみ動作させる

2. CSV出力失敗時の処理
   - ダウンロードできない場合の代替手段
   - エラーメッセージの表示

3. 日付パース失敗時の処理
   - 不正な日付形式の検出
   - デフォルト値（今日）を使用」
```

**実装例**:
```javascript
// localStorageのエラーハンドリング
function saveExpenses(expenses) {
  try {
    localStorage.setItem('expenses', JSON.stringify(expenses));
  } catch (error) {
    console.error('保存エラー:', error);
    alert('データを保存できませんでした。ブラウザの設定を確認してください。');
    // メモリ上のみで動作を継続
  }
}
```

---

## 📊 Before / After 比較

### セキュリティ

| 項目 | Before | After |
|------|--------|-------|
| XSS対策 | ❌ なし | ✅ 全箇所対策済み |
| 入力チェック | ⚠️ 基本のみ | ✅ 厳密なバリデーション |

### パフォーマンス

| 項目 | Before | After |
|------|--------|-------|
| 100件描画 | 150ms | 45ms（3倍高速） |
| DOM操作 | 100回 | 1回 |

### 可読性

| 項目 | Before | After |
|------|--------|-------|
| 関数名 | 不明確 | 明確で説明的 |
| コメント | なし | JSDoc完備 |
| マジックナンバー | あり | 定数化済み |

### エラー処理

| 項目 | Before | After |
|------|--------|-------|
| localStorage | ❌ なし | ✅ try-catch |
| CSV出力 | ❌ なし | ✅ フォールバック |
| 日付処理 | ❌ なし | ✅ デフォルト値 |

---

## 💼 実務での効果

### ケース1: 副業案件での活用

```
状況: クライアントから「バグが多い」と指摘

対応:
1. 全コードをAIレビュー
2. 指摘された問題を全て修正
3. 再納品

結果:
- バグ報告ゼロ
- クライアント満足度向上
- 追加案件の受注
```

### ケース2: コードレビュー時間短縮

```
従来:
自分で書く → レビュー待ち（1-2日） → 修正 → 再レビュー

改善後:
自分で書く → AIレビュー（即座） → 修正 → 人間レビュー

効果:
- レビューサイクルが2日→2時間に短縮
- レビュー指摘が80%減少
- チーム全体の生産性20%向上
```

### ケース3: スキルアップ

```
レビューを受けるたびに:
- 「なぜこの書き方が悪いのか」理解
- 「どう書くべきか」学習
- 次回から同じミスをしない

3ヶ月後:
- レビュー指摘が激減
- コード品質が大幅向上
- チーム内で信頼されるエンジニアに
```

---

## ✅ 完了チェック

この章を終えたら、以下を確認してください：

- [ ] コードレビューを依頼できた
- [ ] セキュリティ、パフォーマンス、可読性を改善できた
- [ ] エラーハンドリングを追加できた
- [ ] Before/Afterで品質向上を体感できた

**すべてチェックできたら、9章へ進みましょう！**

---

## 💡 よくある質問

**Q: レビューの指摘が多すぎて対応しきれない**
A: 優先順位をつけましょう。セキュリティ > パフォーマンス > 可読性の順で対応。すべてを一度に直す必要はありません。

**Q: 指摘内容が理解できない**
A: Claude Codeに「もっと詳しく説明してください」「具体例を見せてください」と聞きましょう。

**Q: レビュー結果を記録しておきたい**
A: レビュー結果をMarkdownファイルに保存して、後で見返せるようにしましょう。

---

## 🔗 次のステップ

次は **9章: テスト自動生成** で、コードの品質をさらに高めるテストの書き方を学びます！
# 9章: テスト自動生成

⏱️ **所要時間**: 座学15分

## 📋 この章の目標

- [ ] テストの重要性を理解する
- [ ] AIによるテスト生成の強みを知る
- [ ] 効果的なテスト戦略を学ぶ

---

## 🎯 なぜテストが必要なのか

### テストなしの開発

```
コード書く → 動作確認 → 「動いた！」 → デプロイ
                               ↓
                        数日後バグ発見
                               ↓
                        「あの時は動いたのに...」
```

**問題点**:
- 😱 修正する度に全機能を手動確認
- 🐛 見落としでバグが本番環境に
- ⏰ 動作確認に時間がかかる
- 💸 バグ修正コストが増大

### テストありの開発

```
コード書く → テスト書く → テスト実行 → 全部通過 → 安心してデプロイ
                                           ↓
                                    修正時もテスト実行
                                           ↓
                                    バグを即座に検出
```

**メリット**:
- ✅ 自動で全機能チェック
- ✅ バグを早期発見
- ✅ 安心してリファクタリング
- ✅ ドキュメントとしても機能

---

## 🤖 AIによるテスト生成の強み

### 従来のテスト作成

```
エンジニア: 「テスト書くの面倒...時間ない...」
結果: テストカバレッジ30%以下
```

**問題**:
- テストコード作成に時間がかかる
- テストケースの洗い出しが大変
- モチベーションが上がらない

### AIによるテスト生成

```
エンジニア: 「このコードのテストを書いて」
AI: 「はい、30秒でテストコード生成しました」
結果: テストカバレッジ90%以上
```

**強み**:
- ⚡ 数秒〜数分で生成
- 🎯 網羅的なテストケース
- 📚 テストの書き方も学べる
- 💪 テストを書く習慣がつく

---

## 📝 テストの種類

### 1. ユニットテスト（単体テスト）

**対象**: 関数やメソッド単位

```javascript
// テスト対象
function add(a, b) {
  return a + b;
}

// テストコード
test('add関数: 2つの数値を足す', () => {
  expect(add(2, 3)).toBe(5);
  expect(add(-1, 1)).toBe(0);
  expect(add(0, 0)).toBe(0);
});
```

**メリット**:
- 素早く実行できる
- 問題箇所を特定しやすい
- テストが簡単

### 2. 統合テスト

**対象**: 複数の機能の連携

```javascript
// テスト対象: タスク追加機能全体
test('タスク追加フロー', () => {
  // 1. タスクを入力
  inputTask('買い物');
  // 2. 追加ボタンをクリック
  clickAddButton();
  // 3. 一覧に表示される
  expect(getTaskList()).toContain('買い物');
  // 4. localStorageに保存される
  expect(localStorage.getItem('tasks')).toBeDefined();
});
```

### 3. E2Eテスト（エンドツーエンド）

**対象**: ユーザーの実際の操作フロー

```javascript
// ブラウザを自動操作
test('ユーザーがタスクを完了するまで', async () => {
  await browser.goto('http://localhost:3000');
  await browser.type('#task-input', '買い物');
  await browser.click('#add-button');
  await browser.click('.task-checkbox');
  expect(await browser.text('.task-item')).toHaveStyle('text-decoration: line-through');
});
```

---

## 🎯 効果的なテスト戦略

### テストピラミッド

```
        /\
       /E2E\      少ない（遅い、壊れやすい）
      /------\
     / 統合   \    中くらい
    /----------\
   / ユニット   \  多い（速い、安定）
  /--------------\
```

**原則**:
- ユニットテストを多く書く（70%）
- 統合テストを適度に書く（20%）
- E2Eテストは重要な部分だけ（10%）

### テストケースの洗い出し

**正常系**:
```
✅ 正しい入力 → 期待通りの動作
例: タスク名「買い物」を入力 → 一覧に表示される
```

**異常系**:
```
⚠️ 不正な入力 → エラー処理
例: タスク名を空で入力 → エラーメッセージ表示
```

**境界値**:
```
🎯 境界の値 → 正しく処理される
例:
- 49文字: OK
- 50文字: OK（上限）
- 51文字: エラー
```

### テストの3A原則

```javascript
test('タスク追加', () => {
  // Arrange（準備）
  const taskName = '買い物';

  // Act（実行）
  addTask(taskName);

  // Assert（検証）
  expect(getTaskList()).toContain(taskName);
});
```

---

## 💬 AIへのテスト生成依頼

### パターン1: 関数のテスト

```
💬 「この関数のテストコードを書いてください:

function calculateTotal(expenses) {
  return expenses.reduce((sum, exp) => sum + exp.amount, 0);
}

以下のケースをテストしてください:
- 通常のケース（複数の経費）
- 空の配列
- 1件のみ
- 金額が0の経費を含む」
```

### パターン2: コンポーネントのテスト

```
💬 「タスク追加機能のテストコードを書いてください。

テストケース:
1. 正常追加: タスク名入力 → 追加 → 一覧に表示
2. 空文字エラー: 空で追加 → エラーメッセージ
3. 文字数制限: 51文字 → エラーメッセージ
4. localStorage保存: 追加後にlocalStorageを確認

使用フレームワーク: Jest」
```

### パターン3: E2Eテスト

```
💬 「経費精算アプリのE2Eテストを書いてください。

テストシナリオ:
1. アプリを開く
2. 経費を3件追加
3. カテゴリ別集計を確認
4. 1件削除
5. 集計が更新されることを確認
6. ページをリロード
7. データが保持されることを確認

使用ツール: Playwright」
```

---

## 💼 実務での活用

### ケース1: 副業案件での品質保証

```
状況: 納品後のバグ修正対応が多い

改善:
1. 主要機能にテストを追加
2. 修正のたびにテスト実行
3. バグの混入を防ぐ

効果:
- バグ報告が80%減少
- 修正対応時間が1/3に短縮
- クライアント満足度向上
```

### ケース2: リファクタリングの安心感

```
状況: コードを改善したいが壊れるのが怖い

改善:
1. 現在のコードにテストを追加
2. テストが全部通ることを確認
3. 安心してリファクタリング
4. テストで動作保証

効果:
- 大胆にコード改善できる
- バグを即座に検出
- コード品質向上
```

### ケース3: チーム開発での信頼性

```
状況: 他人のコード変更が怖い

改善:
1. 全機能にテストを用意
2. Pull Request時にテスト実行
3. 全部通過で安心してマージ

効果:
- デグレ（機能劣化）防止
- チーム全体の生産性向上
- レビュー時間短縮
```

---

## 📊 テストカバレッジ

**テストカバレッジ** = テストでカバーされているコードの割合

```
総コード行数: 1000行
テストされている行数: 800行
カバレッジ: 80%
```

### 目安

```
🏆 優秀: 80%以上
✅ 良好: 60-80%
⚠️ 要改善: 40-60%
❌ 不十分: 40%未満
```

### 重要度で優先順位

```
最優先（100%目指す）:
- ビジネスロジック
- セキュリティ関連
- 決済処理

次に重要（80%目指す）:
- CRUD操作
- バリデーション
- データ変換

優先度低（50%でもOK）:
- UI表示ロジック
- ログ出力
- 設定ファイル読み込み
```

---

## ✅ この章のまとめ

- **テストの重要性**: バグ早期発見、安心してリファクタリング
- **AIの強み**: 数秒で生成、網羅的、学習効果
- **テスト戦略**: ピラミッド型、正常系・異常系・境界値
- **実務効果**: バグ減少、品質向上、生産性アップ

---

## 🔗 次のステップ

次は **10章: テストを書く** で、実際にテストコードを生成して実行します！
# 10章: テストを書く

⏱️ **所要時間**: 実践45分

## 📋 この章の目標

- [ ] 実際にテストコードを生成できる
- [ ] テストを実行して結果を確認できる
- [ ] テスト駆動で開発する感覚を掴む

---

## 🎯 今回やること

経費精算アプリに **テストコードを追加** します。

### 追加するテスト
1. 金額計算のテスト（ユニットテスト）
2. 経費追加機能のテスト（統合テスト）
3. localStorage保存のテスト
4. エラーハンドリングのテスト

---

## 🚀 ハンズオン（45分）

### ステップ1: テスト環境のセットアップ（8分）

```bash
cd expense-tracker
claude
```

テスト環境をセットアップします：

```
💬 「このプロジェクトにJestを使ったテスト環境をセットアップしてください。

必要なもの:
- package.json作成
- Jestインストール
- テスト用のHTMLファイル（jest.config.js）
- テスト実行コマンド設定

ブラウザ環境のテストなので、jest-environmentはjsdomを使用してください。」
```

**Claude Codeがやること**:
1. `package.json` を作成
2. Jest設定ファイルを作成
3. テスト実行スクリプトを設定

**確認**:
```bash
npm install
npm test
```

### ステップ2: 金額計算のテスト（10分）

まず、テスト対象のコードを確認します：

```javascript
// 経費の合計を計算する関数
function calculateTotal(expenses) {
  return expenses.reduce((sum, exp) => sum + exp.amount, 0);
}
```

テストを生成:

```
💬 「calculateTotal関数のテストコードを書いてください。

テストファイル名: calculate.test.js

テストケース:
1. 正常ケース: 複数の経費の合計が正しく計算される
2. 空配列: 0が返される
3. 1件のみ: その金額が返される
4. 負の金額を含む: 正しく計算される（返金のケース）
5. 小数点を含む: 四捨五入される

各テストケースで複数のアサーションを書いてください。」
```

**生成されるテスト例**:
```javascript
// calculate.test.js
describe('calculateTotal', () => {
  test('複数の経費の合計を計算', () => {
    const expenses = [
      { amount: 1000 },
      { amount: 2000 },
      { amount: 3000 }
    ];
    expect(calculateTotal(expenses)).toBe(6000);
  });

  test('空配列は0を返す', () => {
    expect(calculateTotal([])).toBe(0);
  });

  test('1件のみの場合', () => {
    const expenses = [{ amount: 1500 }];
    expect(calculateTotal(expenses)).toBe(1500);
  });

  test('負の金額を含む（返金）', () => {
    const expenses = [
      { amount: 1000 },
      { amount: -500 },
      { amount: 2000 }
    ];
    expect(calculateTotal(expenses)).toBe(2500);
  });
});
```

**テスト実行**:
```bash
npm test calculate.test.js
```

**結果確認**:
```
PASS  calculate.test.js
  calculateTotal
    ✓ 複数の経費の合計を計算 (3ms)
    ✓ 空配列は0を返す (1ms)
    ✓ 1件のみの場合 (1ms)
    ✓ 負の金額を含む（返金） (2ms)

Tests: 4 passed, 4 total
```

### ステップ3: 経費追加機能のテスト（12分）

より複雑な機能のテストを生成:

```
💬 「経費追加機能のテストを書いてください。

テストファイル名: addExpense.test.js

テスト対象の関数:
function addExpense(date, category, description, amount) {
  // バリデーション
  if (!date || !category || !description || !amount) {
    throw new Error('すべての項目を入力してください');
  }
  if (amount <= 0) {
    throw new Error('金額は正の数を入力してください');
  }
  if (amount > 1000000) {
    throw new Error('金額が大きすぎます');
  }

  // 経費オブジェクトを作成
  const expense = {
    id: Date.now(),
    date,
    category,
    description,
    amount: Number(amount)
  };

  // 保存
  saveExpense(expense);
  return expense;
}

テストケース:
【正常系】
1. 正しい入力で経費が追加される
2. 金額が数値に変換される

【異常系】
3. 必須項目が空の場合はエラー
4. 金額が0以下の場合はエラー
5. 金額が100万円超の場合はエラー

【境界値】
6. 金額が1円（最小値）
7. 金額が100万円（最大値）」
```

**テスト実行**:
```bash
npm test addExpense.test.js
```

### ステップ4: localStorage保存のテスト（10分）

```
💬 「localStorage保存機能のテストを書いてください。

テストファイル名: storage.test.js

テスト対象:
function saveExpenses(expenses) {
  try {
    localStorage.setItem('expenses', JSON.stringify(expenses));
    return true;
  } catch (error) {
    console.error('保存エラー:', error);
    return false;
  }
}

function loadExpenses() {
  try {
    const data = localStorage.getItem('expenses');
    return data ? JSON.parse(data) : [];
  } catch (error) {
    console.error('読み込みエラー:', error);
    return [];
  }
}

テストケース:
1. 保存と読み込みが正しく動作する
2. 複数件のデータを保存・読み込み
3. データがない場合は空配列を返す
4. 不正なJSONの場合は空配列を返す（エラーハンドリング）

各テストの前にlocalStorageをクリアしてください。」
```

**テスト実行**:
```bash
npm test storage.test.js
```

### ステップ5: テストカバレッジ確認（5分）

全テストを実行してカバレッジを確認:

```bash
npm test -- --coverage
```

**カバレッジレポート**:
```
---------------------------|---------|----------|---------|---------|
File                       | % Stmts | % Branch | % Funcs | % Lines |
---------------------------|---------|----------|---------|---------|
All files                  |   85.71 |    83.33 |   88.88 |   85.71 |
 calculate.js              |     100 |      100 |     100 |     100 |
 addExpense.js             |   91.66 |    87.50 |     100 |   91.66 |
 storage.js                |   77.77 |    75.00 |   75.00 |   77.77 |
---------------------------|---------|----------|---------|---------|
```

**カバレッジ向上**:
```
💬 「storage.jsのカバレッジが77%です。
テストされていない部分を教えてください。
その部分のテストケースを追加してください。」
```

---

## 🎯 テスト駆動開発（TDD）を体験

### TDDの流れ

```
Red（失敗） → Green（成功） → Refactor（改善）
```

**実践してみよう**:

#### ステップ1: Red（失敗するテストを書く）

```
💬 「フィルター機能のテストを先に書いてください。

テスト対象（まだ実装していない機能）:
function filterExpensesByCategory(expenses, category) {
  // カテゴリでフィルタリング
}

テストケース:
1. '交通費'でフィルター → 交通費のみ返す
2. '全て'でフィルター → 全件返す
3. 該当なし → 空配列を返す」
```

**テスト実行**:
```bash
npm test filter.test.js
```

**結果**: ❌ FAIL（関数が実装されていないため）

#### ステップ2: Green（テストが通る最小限の実装）

```
💬 「filter.test.jsのテストが通るように、
filterExpensesByCategory関数を実装してください。」
```

**テスト実行**:
```bash
npm test filter.test.js
```

**結果**: ✅ PASS

#### ステップ3: Refactor（コードを改善）

```
💬 「filterExpensesByCategory関数を、
より効率的でわかりやすいコードに改善してください。
テストが通ることを確認しながら改善してください。」
```

**テスト実行して確認**:
```bash
npm test filter.test.js
```

**結果**: ✅ PASS（動作は変わらず、コードが改善された）

---

## 💼 実務での活用

### ケース1: バグ修正時

```
状況: 「金額が正しく計算されない」バグ報告

対応手順:
1. バグを再現するテストを書く
   test('バグ: 小数点の丸め誤差', () => {
     // 現在は失敗する
   });

2. テストが失敗することを確認（Red）

3. バグを修正（Green）

4. テストが成功することを確認

5. 同じバグが二度と起きない
```

### ケース2: リファクタリング時

```
状況: コードが読みにくいので改善したい

対応手順:
1. 現在の動作をテストで記録
   test('現在の動作', () => {
     // すべてのパターンをテスト
   });

2. テストが通ることを確認

3. 安心してリファクタリング

4. テストで動作保証
```

### ケース3: チーム開発時

```
状況: 他の人がコードを変更

保護策:
1. すべての機能にテストを用意

2. Pull Request時に自動テスト実行
   → CIで npm test を実行

3. 全部通過でマージ許可

4. デグレ（機能劣化）を防止
```

---

## 📊 テストの効果測定

### 導入前 vs 導入後

| 項目 | 導入前 | 導入後 |
|------|--------|--------|
| バグ発生率 | 10件/月 | 2件/月（80%減） |
| バグ修正時間 | 2時間/件 | 30分/件 |
| リファクタリング頻度 | 年1回 | 月1回 |
| 安心感 | ⚠️ 不安 | ✅ 安心 |

### 時間投資と効果

```
テスト作成時間: +20%
バグ修正時間: -60%
手動テスト時間: -80%

総合: 開発時間 -30%短縮
```

---

## ✅ 完了チェック

この章を終えたら、以下を確認してください：

- [ ] テスト環境をセットアップできた
- [ ] ユニットテストを書けた
- [ ] 統合テストを書けた
- [ ] テストを実行して結果を確認できた
- [ ] TDDの流れを体験できた

**すべてチェックできたら、セッション2完了です！**

---

## 💡 よくある質問

**Q: テストを書くのに時間がかかる**
A: 最初は時間がかかりますが、AIが生成してくれるので従来の1/5の時間で済みます。バグ修正時間の短縮を考えれば十分ペイします。

**Q: 100%カバレッジを目指すべき？**
A: いいえ。重要な部分を80%カバーすれば十分です。UIの細かい表示ロジックなどは無理にテストしなくてOK。

**Q: テストが壊れやすい**
A: 実装の詳細ではなく、動作（what）をテストしましょう。内部実装（how）に依存しないテストを書くことが大切です。

---

## 🔗 次のステップ

次は **11章: リファクタリング技法** で、テストに守られながらコードを改善する方法を学びます！
